<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>20210330更新日志</title>
    <url>/2021/03/30/21-06-17/</url>
    <content><![CDATA[<p> 1.标签和分类页面可以进去了</p>
<p>2.添加<del>超级卡哇伊的</del>头像</p>
<p>3.删除掉无用的about（以后可能有用）</p>
<p>其他博文还在路上</p>
]]></content>
      <categories>
        <category>更新日志</category>
      </categories>
  </entry>
  <entry>
    <title>20210401更新日志</title>
    <url>/2021/04/01/21-08-26/</url>
    <content><![CDATA[<p>1.底部添加点击量（貌似有点小问题？）</p>
]]></content>
      <categories>
        <category>更新日志</category>
      </categories>
  </entry>
  <entry>
    <title>20210331更新日志</title>
    <url>/2021/03/31/19-33-55/</url>
    <content><![CDATA[<p>1.添加搜索功能</p>
<p>2.在“关于”界面内增加了简介</p>
]]></content>
      <categories>
        <category>更新日志</category>
      </categories>
  </entry>
  <entry>
    <title>20210410更新日志</title>
    <url>/2021/04/10/23-53-08/</url>
    <content><![CDATA[<p>1.头像可以转动了，而且变圆了</p>
]]></content>
      <categories>
        <category>更新日志</category>
      </categories>
  </entry>
  <entry>
    <title>20210406更新日志</title>
    <url>/2021/04/06/23-04-49/</url>
    <content><![CDATA[<p>1.现在背景有奇怪的动态折线了</p>
]]></content>
      <categories>
        <category>更新日志</category>
      </categories>
  </entry>
  <entry>
    <title>20210403更新日志</title>
    <url>/2021/04/03/23-44-58/</url>
    <content><![CDATA[<p>1.增加底部字数统计</p>
]]></content>
      <categories>
        <category>更新日志</category>
      </categories>
  </entry>
  <entry>
    <title>ABB(manacher)</title>
    <url>/2021/04/08/23-10-06/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>Fernando was hired by the University of Waterloo to finish a development project the university started some time ago. Outside the campus, the university wanted to build its representative bungalow street for important foreign visitors and collaborators.<br>Currently, the street is built only partially, it begins at the lake shore and continues into the forests, where it currently ends. Fernando’s task is to complete the street at its forest end by building more bungalows there. All existing bungalows stand on one side of the street and the new ones should be built on the same side. The bungalows are of various types and painted in various colors.<br>The whole disposition of the street looks a bit chaotic to Fernando. He is afraid that it will look even more chaotic when he adds new bungalows of his own design. To counterbalance the chaos of all bungalow shapes, he wants to add some order to the arrangement by choosing suitable colors for the new bungalows. When the project is finished, the whole sequence of bungalow colors will be symmetric, that is, the sequence of colors is the same when observed from either end of the street.<br>Among other questions, Fernando wonders what is the minimum number of new bungalows he needs to build and paint appropriately to complete the project while respecting his self-imposed<br>bungalow color constraint.</p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>The first line contains one integer N (1 ≤ N ≤ 4 ×105 ), the number of existing bungalows in the street. The next line describes the sequence of colors of the existing bungalows, from the beginning of the street at the lake. The line contains one string composed of N lowercase letters (“a” through “z”), where different letters represent different colors.</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>Output the minimum number of bungalows which must be added to the forest end of the street and painted appropriately to satisfy Fernando’s color symmetry demand.</p>
<h4 id="样例输入-Copy"><a href="#样例输入-Copy" class="headerlink" title="样例输入 Copy"></a>样例输入 <a href="javascript:CopyToClipboard($('#sampleinput').text())">Copy</a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">abb</span><br></pre></td></tr></table></figure>

<h4 id="样例输出-Copy"><a href="#样例输出-Copy" class="headerlink" title="样例输出 Copy"></a>样例输出 <a href="javascript:CopyToClipboard($('#sampleoutput').text())">Copy</a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<p>本题是求最少加几个字符可以使该串变成回文串，那么很显然使用马拉车定理求出可以延伸到末尾的回文串再加上其坐标即可，关于manacher 定理敬请查看我上一篇博文 。 </p>
<p>下面贴代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">int</span>  t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; y ? x : y ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e5</span> ;</span><br><span class="line"><span class="keyword">char</span> str[ N + <span class="number">10</span> ] ;</span><br><span class="line"><span class="keyword">char</span> ns[ <span class="number">2</span>*N + <span class="number">10</span>] ;</span><br><span class="line"><span class="keyword">int</span> r[<span class="number">2</span> *N +<span class="number">10</span>] ;</span><br><span class="line"><span class="keyword">int</span> len ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_change</span><span class="params">(<span class="keyword">char</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ns[<span class="number">0</span>] = <span class="string">&#x27;@&#x27;</span> ;</span><br><span class="line">    ns[<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        ns[<span class="number">2</span>*i + <span class="number">2</span>] = a[i] ;</span><br><span class="line">        ns[<span class="number">2</span>*i + <span class="number">3</span>] = <span class="string">&#x27;#&#x27;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    ns[<span class="number">2</span>*len + <span class="number">2</span>] = <span class="string">&#x27;$&#x27;</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0x3f3f3f3f</span> ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manacher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span> ,maxid = <span class="number">0</span> ;</span><br><span class="line">    len = <span class="number">2</span> * len + <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i ++)</span><br><span class="line">    &#123;     <span class="keyword">if</span>(maxid &gt; i )</span><br><span class="line">        r[i] = <span class="built_in">min</span>(r [<span class="number">2</span> * id - i] , maxid - i ) ;</span><br><span class="line">        <span class="keyword">else</span> r[i] = <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(ns[i + r[i]] ==ns [ i - r[i]] )</span><br><span class="line">        r[i] ++ ;</span><br><span class="line">    <span class="keyword">if</span>(r[i] + i &gt; maxid)</span><br><span class="line">    &#123;</span><br><span class="line">        maxid = r[i] + i ;</span><br><span class="line">        id = i ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = len - <span class="number">1</span> ; j &gt;=<span class="number">0</span>  ; j --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(r[j] + j == len )</span><br><span class="line">           ans = <span class="built_in">min</span>(ans,t - r[j] + <span class="number">1</span> ) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;len) ;</span><br><span class="line">t = len;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str) ;</span><br><span class="line"><span class="built_in">pre_change</span>(str) ;</span><br><span class="line"><span class="comment">//puts(ns) ;</span></span><br><span class="line"><span class="built_in">manacher</span>() ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title>Et Tu Brute?</title>
    <url>/2021/04/11/21-52-12/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>Caesar has been betrayed! He always thought his best friends were the senators of Rome, but it turns out they are trying to kill him. Even his best friend, Marcus Junius Brutus, is in on the plot. Luckily, he’s managed to get away, for now. If he can make it out of the senate he’ll be okay, and he can overthrow the senate and take over Rome.<br>Unfortunately, he’s a little rattled, and is not making smart decisions. Every minute, he is randomly choosing which room he enters and hides in for the next minute. In each room there is a p% chance that he will be captured. After m minutes the senators will give up the search and go back to their homes, allowing him to escape. Calculate the chance that he will escape if he chooses rooms at random.</p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>The first line of the input will be a single integer, n ≤ 1, 000. There will be n test cases that follow.<br>Each test case will start with a line of 2 integers: the number of rooms 5 ≤ r ≤ 50 and the number of minutes Caesar must survive, m ≤ 10. The next r lines will consist of a floating point number p &lt; 1 denoting the probability that Caesar survives for the next minute in this room and 4 integers between 1 and r (inclusive on both ends) denoting which rooms the current room is connected to. Caesar always spends the first minute in room 1.<br>Note: The senate is weird, just because room a leads to room b does not mean Caesar can get back into room a from room b.</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>Output a single floating point number denoting the probability that Caesar survives. The output should be accurate and truncate to three decimal places.</p>
<h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">5 3</span><br><span class="line">0.50 2 3 4 5</span><br><span class="line">0.25 1 3 4 5</span><br><span class="line">0.30 1 2 4 5</span><br><span class="line">0.80 1 2 3 5</span><br><span class="line">0.60 1 2 3 4</span><br></pre></td></tr></table></figure>

<h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.113</span><br></pre></td></tr></table></figure>

<p>样例大意是给定有5个房间，按顺序给出，凯撒需要存活3分钟，后面按1到5的顺序分别给出了其存活概率以及该房间通向的四个房间，不可逆向。</p>
<p>显然这是一道简单的概率题，其向多条路并且有终点的性质，显然容易想到递归，并且递归的终点就是时间到了3分钟 ，再加上其总共会给出四个房间，最后算出来的概率还需要/4</p>
<p>下面贴出AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">double</span> probs[<span class="number">55</span>];</span><br><span class="line"><span class="keyword">int</span> rooms[<span class="number">55</span>][<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">return</span> ( <span class="built_in">dfs</span>(m<span class="number">-1</span>, rooms[id][<span class="number">1</span>])</span><br><span class="line">              + <span class="built_in">dfs</span>(m<span class="number">-1</span>, rooms[id][<span class="number">2</span>])</span><br><span class="line">              + <span class="built_in">dfs</span>(m<span class="number">-1</span>, rooms[id][<span class="number">3</span>])</span><br><span class="line">              + <span class="built_in">dfs</span>(m<span class="number">-1</span>, rooms[id][<span class="number">4</span>]) ) / <span class="number">4</span> * probs[id];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) ;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="keyword">int</span> r, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;r,&amp;m) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>  i = <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">           <span class="built_in">scanf</span>(<span class="string">&quot;%lf%d%d%d%d&quot;</span>,probs + i , rooms[i] + <span class="number">1</span> ,rooms[i] +<span class="number">2</span> , rooms[i] + <span class="number">3</span> ,rooms[i] + <span class="number">4</span> ) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.3f\n&quot;</span>, <span class="built_in">dfs</span>(m, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>面对这种多个相同过程并且有相似的终点题目，应该首先联想到递归！</p>
]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>colorful slimes(DP)</title>
    <url>/2021/04/04/22-56-07/</url>
    <content><![CDATA[<p>题目描述<br>Snuke lives in another world, where slimes are real creatures and kept by some people. Slimes come in N colors. Those colors are conveniently numbered 1 through N. Snuke currently has no slime. His objective is to have slimes of all the colors together.</p>
<p>Snuke can perform the following two actions:</p>
<p>Select a color i (1≤i≤N), such that he does not currently have a slime in color i, and catch a slime in color i. This action takes him ai seconds.</p>
<p>Cast a spell, which changes the color of all the slimes that he currently has. The color of a slime in color i (1≤i≤N−1) will become color i+1, and the color of a slime in color N will become color 1. This action takes him x seconds.</p>
<p>Find the minimum time that Snuke needs to have slimes in all N colors.</p>
<p>Constraints<br>2≤N≤2,000<br>ai are integers.<br>1≤ai≤109<br>x is an integer.<br>1≤x≤109<br>输入<br>The input is given from Standard Input in the following format:</p>
<p>N x<br>a1 a2 … aN<br>输出<br>Find the minimum time that Snuke needs to have slimes in all N colors.<br>样例输入 Copy<br>2 10<br>1 100<br>样例输出 Copy<br>12<br>提示<br>Snuke can act as follows:</p>
<p>Catch a slime in color 1. This takes 1 second.<br>Cast the spell. The color of the slime changes: 1 → 2. This takes 10 seconds.<br>Catch a slime in color 1. This takes 1 second.<br>本题大意是Snuke 想要获得N种颜色，他有两种操作，一是直接付出对应颜色的代价来获得，二是所有获得的颜色i变成颜色i + 1。<br>所以想要获得颜色i 有两种方法<br>1.直接付出相应代价。<br>2.进行操作二j次使 i-j（已经获得）变成 i 。<br>不妨设进行操作二的次数为j，显然想要以最小的代价获得全部的颜色，只需要最多n-1次操作二即可。<br>于是有 0 &lt;= j &lt;= n - 1 。<br>我们发现进行操作二的次数最终会在总代价上加上 j * x，<br>不妨设dp[ i ] [ j ]表示进行j次操作时获得第i个颜色的最小代价。<br>于是可以通过枚举j来获得操作次数为j时获得每种颜色付出的最小代价，最终加和即可。<br>状态转移方程 dp[ i ] [ j ] = min ( a[ i - j ] , dp [ i ] [ j - 1 ])<br>a[i - j ] 表示在获得第i个颜色时进行了第j次操作（已经做了j - 1 次）并以后移了j次的代价获得，<br>dp[ i ] [ j - 1 ] 表示在获得第i个颜色时（已经进行了j-1次操作），以当前代价直接获得。<br>下面贴代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span>`</span></span><br><span class="line">`<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span>`</span></span><br><span class="line">`<span class="keyword">using</span> <span class="keyword">namespace</span> std;`</span><br><span class="line">`<span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll ;`</span><br><span class="line"></span><br><span class="line">`<span class="keyword">int</span> dp[<span class="number">2020</span>][<span class="number">2020</span>];`</span><br><span class="line">`ll mi = <span class="number">0x3f3f3f3f3f3f3f3f</span> ;`</span><br><span class="line">`int main()`</span><br><span class="line">`&#123;`</span><br><span class="line">`ll n , x ,sum;`</span><br><span class="line">`<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;x) ;`</span><br><span class="line">`<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i ++)`</span><br><span class="line">`<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;dp[i][<span class="number">0</span>]) ;<span class="comment">//这里进行了空间优化，直接用dp[i][0] 表示a[i]即可 。` </span></span><br><span class="line">`<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i ++)`</span><br><span class="line">`<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n - <span class="number">1</span> ; j ++)&#123;`</span><br><span class="line">        `<span class="keyword">int</span> k = i - j ;`</span><br><span class="line">        `<span class="keyword">if</span>(k &lt;=<span class="number">0</span>) k += n  ;<span class="comment">//指向后移j次的代价可能会循环`</span></span><br><span class="line">        `dp[i][j] = <span class="built_in">min</span>(dp[i][j<span class="number">-1</span>],dp[k][<span class="number">0</span>]) ;`</span><br><span class="line">    `&#125;`</span><br><span class="line">`<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n - <span class="number">1</span>; i ++)&#123;`</span><br><span class="line">        `sum = <span class="number">0</span> ;`</span><br><span class="line">        `<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; j ++)`</span><br><span class="line">            `sum += dp[j][i] ;`</span><br><span class="line">            `sum += i * x ;<span class="comment">//最后求得各个状态付出代价总和`</span></span><br><span class="line">            `mi = <span class="built_in">min</span>(mi,sum) ;<span class="comment">//取得其中的最小值`</span></span><br><span class="line">    `&#125;`</span><br><span class="line">`<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,mi) ;`</span><br><span class="line">`<span class="keyword">return</span> <span class="number">0</span> ；` </span><br><span class="line">`&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>one of each</title>
    <url>/2021/04/09/23-26-21/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>You are given a sequence of n integers x = [x1,x2,…,xn] and an integer k . It is guaranteed that 1 ≤ xi ≤ k , and every integer from 1 to k appears in the list x at least once.<br>Find the lexicographically smallest subsequence of x that contains each integer from 1 to k exactly once. </p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>The first line of input contains two integers n and k ( 1 ≤ k ≤ n ≤ 2 ∙105), where n is the size of the sequence, and the sequence consists only of integers from 1 to k .<br>Each of the next n lines contains a single integer xi( 1 ≤ xi ≤ k ). These are the values of the sequence X in order. It is guaranteed that every value from 1 to k will appear at least once in the sequence X . </p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>Output a sequence of integers on a single line, separated by spaces. This is the lexicographically smallest subsequence of X that contains every value from 1 to k. </p>
<h4 id="样例输入-Copy"><a href="#样例输入-Copy" class="headerlink" title="样例输入 Copy"></a>样例输入 <a href="javascript:CopyToClipboard($('#sampleinput').text())">Copy</a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【样例1】</span><br><span class="line">6 3 </span><br><span class="line">3 </span><br><span class="line">2 </span><br><span class="line">1 </span><br><span class="line">3 </span><br><span class="line">1 </span><br><span class="line">3 </span><br><span class="line">【样例2】</span><br><span class="line">10 5</span><br><span class="line">5 </span><br><span class="line">4 </span><br><span class="line">3 </span><br><span class="line">2 </span><br><span class="line">1 </span><br><span class="line">4 </span><br><span class="line">1 </span><br><span class="line">1 </span><br><span class="line">5 </span><br><span class="line">5 </span><br></pre></td></tr></table></figure>

<h4 id="样例输出-Copy"><a href="#样例输出-Copy" class="headerlink" title="样例输出 Copy"></a>样例输出 <a href="javascript:CopyToClipboard($('#sampleoutput').text())">Copy</a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【样例1】</span><br><span class="line">2 1 3 </span><br><span class="line">【样例2】</span><br><span class="line">3 2 1 4 5 </span><br></pre></td></tr></table></figure>

<p>本题大意为给定一段只包含1<del>k的一段数字序列，求从包含1</del>k的字典序最小序列 。 </p>
<p>要保证序列都含有1~k 的数字，若当前数字有且仅有一个并且栈内没有该数字，直接压入栈即可，若当前数字有多个且下一个数字比它小，直接弹出栈顶的元素，压入新元素入栈即可，最后倒序输出略有麻烦。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200000</span>+<span class="number">6</span>] ;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">200000</span>+<span class="number">6</span>] ;<span class="comment">//由于数据不大，用num记录各个数字的数量</span></span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">200000</span>+<span class="number">6</span>] ;<span class="comment">//用vis 记录该数字是否在栈内</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n ,  k ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k) ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )&#123;</span><br><span class="line">       <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a + i ) ;</span><br><span class="line">       num[a[i]] ++ ;</span><br><span class="line"> &#125;</span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt;cnm ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )&#123;</span><br><span class="line">    num[a[i]] -- ;</span><br><span class="line">    <span class="keyword">if</span>(!vis[a[i]])&#123;<span class="comment">//当且仅当栈内没有该元素时考虑入栈</span></span><br><span class="line">        vis[a[i]]  = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span>(!cnm.<span class="built_in">empty</span>()&amp;&amp;num[cnm.<span class="built_in">top</span>()] &amp;&amp; cnm.<span class="built_in">top</span>() &gt; a[i])&#123;<span class="comment">//弹出比它大又需要放在后面的元素</span></span><br><span class="line">            vis[cnm.<span class="built_in">top</span>()] = <span class="number">0</span> ;</span><br><span class="line">            cnm.<span class="built_in">pop</span>() ;</span><br><span class="line">        &#125;</span><br><span class="line">        cnm.<span class="built_in">push</span>(a[i])  ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans[k+<span class="number">5</span>] ;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">while</span>(!cnm.<span class="built_in">empty</span>())&#123;<span class="comment">//这里将栈内元素倒序输出</span></span><br><span class="line">ans[p ++ ] = cnm.<span class="built_in">top</span>() ;</span><br><span class="line">cnm.<span class="built_in">pop</span>() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = p - <span class="number">1</span> ; i &gt;= <span class="number">0</span> ; i --)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[i]) ;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>本题给的数据量仅仅允许o（n），所以考虑使用方便的数据结构！</p>
]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/03/29/20-24-16/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>大数乘积取模详解</title>
    <url>/2021/03/31/20-06-38/</url>
    <content><![CDATA[<p>对于给定三个数 a ，b  ,  mod .</p>
<p>求a * b模mod，</p>
<p>一般情况的最优策略是</p>
<p> ((a % mod) * (b %mod)) % mod </p>
<p><u>当a ， b ，mod 都很大的时候</u></p>
<p><u>还是会爆long long int(主要是mod太大)</u></p>
<p>这个时候正确的思路将a或者b拆解成不同部分乘积求和</p>
<p>类比快速幂的原理。</p>
<p>举个实例：求 3 * 15 对mod取模</p>
<p>将15 转化为二进制数1111</p>
<p>那么问题就转化为 3 * (1111)(2) %mod</p>
<p>分解1111得到</p>
<p>3 * (1 * 2^3 + 1* 2^2 + 1* 2^1 + 1*2^0)%mod </p>
<p>那么事实上我们只需将其各部分乘积分别取模，最后求和再取模即可。</p>
<p>下面贴代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span>  ll;</span><br><span class="line"><span class="function">ll <span class="title">mod_mult</span><span class="params">(ll a, ll b, ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a %= mod;<span class="comment">//先降低a，b的规模</span></span><br><span class="line">    b %= mod;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)<span class="comment">//判断b的最后一位是否为1,是1就加是0就不加嘛</span></span><br><span class="line">         &#123;</span><br><span class="line">            ans += a;<span class="comment">//我们让ans加上a，其实实现了括号内的加法操作</span></span><br><span class="line">            ans%=mod;</span><br><span class="line">        &#125;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;<span class="comment">//将a乘以2，这就是括号外面的a与括号内2的倍数的乘积</span></span><br><span class="line">        a%=mod;<span class="comment">//并且将a不断取模</span></span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;<span class="comment">//让b的二进制数向右移动一位，即b/2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ll  a,b,mod;</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;a,&amp;b,&amp;mod) ; </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">mod_mult</span>(a,b,mod)) ;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>我自认为已经讲得非常详细啦，为了优化运行速度使用了位运算，不熟悉位运算的小伙伴可以去了解一下哦。</p>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>取模</tag>
      </tags>
  </entry>
  <entry>
    <title>求1到n内所有数因子的和</title>
    <url>/2021/04/05/20-35-53/</url>
    <content><![CDATA[<p>求 1 ~ n范围内 各个数因子的和，数论中给出了如下结论 ：</p>
<p>n * ( 1 / 1 + 1/2 + 1/3 + …… + 1/ n) ; </p>
<p>原来在1到n中，1可以作为 n/ 1个数的因子 ； </p>
<p>2 可以作为 n / 2 个数的因子 ； </p>
<p>3可以作为 n / 3 个数的因子；</p>
<p>由此得出上面式子</p>
<p>将每个部分视为n / x</p>
<p>可知可以降低范围到√n</p>
<p>下面贴代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(l=<span class="number">1</span>; l&lt;=t; l++)</span><br><span class="line">            ans += n/l;</span><br><span class="line">    ans = ans*<span class="number">2</span>-t*t;<span class="comment">//其中t * t &lt;= n</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>

<p>这里贴出另一种代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">LL l, r;</span><br><span class="line">   LL ans = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>( l = <span class="number">1</span>; l &lt;= n; l = r+<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       r = n/(n/l);</span><br><span class="line">       ans += n/l *(r - l + <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>苹果旅游（DP）</title>
    <url>/2021/04/02/21-16-33/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>xiaoT发现山谷相当的大，准确地说应该是相当的长，xiaoT想到山谷的那头去看看，但是靠xiaoT走路的速度，到那边要n年。还好xiaoT可以买一些苹果，它把这些苹果当成动力，根据火箭发射的原理，如果xiaoT把苹果向后扔，xiaoT就会向前进。</p>
<p>苹果有两种，一种青苹果，一种红苹果。<br>已知到山谷的长度为k，用一些（同一种类）苹果可以通过的路程为1。<br>苹果的价格是不一样的，红苹果的价格是红苹果个数的四次方。<br>青苹果的价格就是青苹果个数。</p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>第一行有一个正整数n表示xiaoT走路到那边需要的时间。<br>第二行有一个正整数k表示山谷的长度。<br>接下来k行，每行两个正整数，分别表示通过该段：<br>如果使用红苹果，则需要的数量为a<br>如果使用青苹果，则需要的数量为b</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>输出只有一个数，买苹果的最少的花费。</p>
<h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2296</span><br><span class="line">3</span><br><span class="line">3 1000</span><br><span class="line">2 5000</span><br><span class="line">4 8000</span><br></pre></td></tr></table></figure>

<h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2296</span><br></pre></td></tr></table></figure>

<h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>样例解释<br>第1段用青苹果，第2、3段用红苹果，花费是1000+(2+4)4</p>
<p>对于30%的数据，k≤10<br>对于50%的数据，k≤25<br>对于100%的数据，k≤50<br>对于100%的数据，每段路消耗的红苹果的数量≤10<br>对于100%的数据，每段路消耗的青苹果的数量≤107</p>
<p>题目大意是给定有k段路，每段路可以选择使用对应量的青苹果或者红苹果通过，使用青苹果付出的代价就是青苹果的数量，使用红苹果的代价是最终红苹果数量的4次方。</p>
<p><u>通过读题不难知道正整数n对本题结果完全没有影响，属于没有用的变量。</u></p>
<p>由给定的k范围可知若枚举每一段路，时间复杂度能够达到2^50，这个显然不合适</p>
<p>通过经验判断，这是一道dp题。</p>
<p>最终红苹果需要付出的代价取决于其最终的数量。也就是说我们不能在递推的过程中直接得出当时付出的代价，但是青苹果的数量即为付出的代价，换言之我们可以<u>通过枚举红苹果的数量，最终得到最少的青苹果数量来获得红苹果数量一定时的最小总代价。</u></p>
<p>不妨设dp[i] [j] 表示<u><strong>当红苹果数量为   j   时，前   i   段路中使用青苹果的最小数量。</strong></u></p>
<p>不妨用a[i]  , b[i]分别表示第i段路所需要的红苹果和青苹果的数量 。 </p>
<p>当 j  &lt;  a[i] 时，此时红苹果数量为  j ，可知经过第 i 段路一定没有选择红苹果 ，即：</p>
<p>dp[i] [j] = dp[i-1] [j] + b[i] ; </p>
<p>当j  &gt;= a[i] 时，那就有两种情况，一种是红苹果数量为j时没有选择 a[i] ,而是选择了青苹果即：</p>
<p>dp[i] [j] = dp[i- 1] [j] + b[i] ; </p>
<p>若此时选择了a[i] ,则dp[i] [j] = dp[i-1] [j-a[i]] ; </p>
<p>可知状态转移方程 dp[i] [j] = min (dp[i-1] [j] + b[i] , dp[i-1] [j-a[i]]) </p>
<p>最终枚举红苹果的数量，加上递推终点的青苹果数量即可。</p>
<p>那么下面贴AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> t ;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll ;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x  ,<span class="keyword">long</span> <span class="keyword">long</span>  <span class="keyword">int</span> y )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; y ? x : y ;</span><br><span class="line">&#125;</span><br><span class="line">ll dp[<span class="number">55</span>][<span class="number">505</span>] ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t) ;</span><br><span class="line">    <span class="keyword">int</span> k ;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k) ;</span><br><span class="line">    ll a[k+<span class="number">5</span>],b[k+<span class="number">5</span>] ;</span><br><span class="line">    ll sum = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span> ; i &lt;= k ; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,a+i,b+i) ;</span><br><span class="line">        sum += a[i] ;<span class="comment">//记录红苹果最大的数量用以枚举</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span> ; i &lt;= k ; i ++ )</span><br><span class="line">    <span class="keyword">for</span>(ll j = sum ; j &gt;= <span class="number">0</span> ; j --)</span><br><span class="line">    &#123;   <span class="keyword">if</span>(j  &lt; a[i])</span><br><span class="line">          dp[i][j] = dp[i<span class="number">-1</span>][j] + b[i] ;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(j &gt;= a[i])</span><br><span class="line">          dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j] + b[i],dp[i<span class="number">-1</span>][j-a[i]]) ;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   ll mi = <span class="number">0x3f3f3f3f</span> ;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span> ;  i&lt;= sum ; i ++ )</span><br><span class="line">    mi = <span class="built_in">min</span>(mi,dp[k][i] + i * i * i * i ) ;<span class="comment">//找到最小可能值即可</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,mi) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Manacher算法</title>
    <url>/2021/04/07/20-30-05/</url>
    <content><![CDATA[<p>Manacher 算法 ，用以求解最长回文字符串，其时间复杂度为o（n）,</p>
<p>这个算法首先最帅的一点在于对奇偶字符串的处理，例如aba和abba，那么仅仅需要在每个字符之间（包括外层）插入一个原字符串没有的字符，一般用“#”或者“$”，此时aba变成了：</p>
<p>#a#b#a# <strong>仍是以b为中心的奇数长度回文字符串</strong></p>
<p>此时abba变成了：</p>
<p>#a#b#b#a#<strong>这是其变成了以“#”为中心的奇数长度回文字符串</strong></p>
<p>有了以上的处理就可以将奇偶字符串统一拓展为奇数长度字符串进行处理。</p>
<p>但是manacher 算法中对字符串的处理还要进行防止越界处理（具体原因见下文处理）</p>
<p>比如对abba字符串的处理（注意下标）</p>
<p>a    b    b    a  其下标为：</p>
<p>0    1    2    3预处理后的字符串</p>
<p>   @#a#b#b#a#$ 其下标为</p>
<p>   0 1 23456789 10 </p>
<p>1.我们处理过的要用的字符串从下标从1 开始</p>
<p>2.为防止越界要在新字符串下标为0的位置 和字符串的末尾添加两个原来串没有又不同的字符</p>
<p>我这里用的就是@ 和 $</p>
<p>下面贴预处理的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_change</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    newstr[<span class="number">0</span>] = <span class="string">&#x27;@&#x27;</span> ; </span><br><span class="line">    newstr[<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span> ; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        newstr[<span class="number">2</span>*i + <span class="number">2</span> ] = str[i] ; </span><br><span class="line">        newstr[<span class="number">2</span>*i + <span class="number">3</span> ] = <span class="string">&#x27;#&#x27;</span> ; </span><br><span class="line">    &#125;</span><br><span class="line">    newstr[<span class="number">2</span> * len + <span class="number">2</span> ] = <span class="string">&#x27;$&#x27;</span> ; </span><br><span class="line">    <span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就预处理完毕了，接下来是该最精彩的部分 ； </p>
<p>用一个数组 r [i] 记录 以newstr[i]为中心的最长回文串的半径长度  </p>
<p><strong>r[i]数组是马拉车算法的核心！！！！</strong></p>
<p>用 maxid 记录 在位置 i 以前的回文串右边能延伸到的最大位置</p>
<p>即maxid = id  + r[id] ; </p>
<p>id 即对应maxid</p>
<p>注意这个id 不是 i 而是之前某个位置的下标 ！ </p>
<p>然后就用了动态规划的思想以o（n）的复杂度更新了所有的newstr[i] 对应的r[i] ; </p>
<p>接下来先看代码!</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manacher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> id , maxid = <span class="number">0</span> ; </span><br><span class="line">   len = <span class="number">2</span> * len + <span class="number">2</span> ； </span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i ++ )</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">if</span>(maxid &gt; i )</span><br><span class="line">   r[i] = <span class="built_in">min</span>(r[<span class="number">2</span> * id - i] , maxid - i ) ; </span><br><span class="line">   <span class="keyword">else</span> r[i] = <span class="number">1</span> ; </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">while</span>(newstr[i + r[i]] == newstr[i - r[i]])</span><br><span class="line">         r[i] ++ ; </span><br><span class="line">   <span class="keyword">if</span>( r[i] + i &gt; maxid)</span><br><span class="line">   &#123;</span><br><span class="line">       maxid = r[i] + i ;</span><br><span class="line">       id = i ; </span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看看动态规划更新r[i]的核心部分</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i ++ )</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">if</span>(maxid &gt; i )</span><br><span class="line">   r[i] = <span class="built_in">min</span>(r[<span class="number">2</span> * id - i] , maxid - i ) ; </span><br><span class="line">   <span class="keyword">else</span> r[i] = <span class="number">1</span> ; </span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<p><img src="data:image/png;base64,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" alt="image"></p>
<p>如上图由 已知可以知道 j = 6 , i  = 14 , maxid  = mi  = 17  , id = 10  ;</p>
<p>可以明显看出r[i] = 4    ，即11到i</p>
<p>r[j] = 6 ; 即j 到11</p>
<p>j 是i 关于id对称位置的下标</p>
<p>并且有j = 2 * id - i  ; </p>
<p>根据对称原理可知</p>
<p>若newstr[j]处有回文串 ， 则其对称位置newstr[i]处最大回文串半径r[i] = r[j] ; </p>
<p>如上图这里j处对称过来的回文串长度 加上i的坐标显然超过了mi 即 maxid  ，这时r[i]只需要取mi - i 即可</p>
<p>即有状态转移方程 r[i] = min(r[j] , maxid - i) ; </p>
<p>即上面核心代码maxid &gt; i的部分</p>
<p>若maxid &lt; i，很显然在 i 并不在回文串id -maxid 到id + maxid内，此时newstr[i]只能跟自己构成回文串了，故r[i] = 1 ; 然后是</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(newstr[i + r[i]] == newstr[i - r[i]])</span><br><span class="line">       r[i] ++ ; </span><br></pre></td></tr></table></figure>

<p>直接更新位置i处的回文串半径，不再赘述。</p>
<p>最后有</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(newstr[i + r[i]] == newstr[i - r[i]])</span><br><span class="line">        r[i] ++ ; </span><br><span class="line">  <span class="keyword">if</span>( r[i] + i &gt; maxid)</span><br><span class="line">  &#123;</span><br><span class="line">      maxid = r[i] + i ;</span><br><span class="line">      id = i ; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如上文所述 maxid为i前回文串向后延伸的最远位置 ，若i处向后延伸的回文串还能更远，那么更新</p>
<p>maxid ，这时候id 就更新为 i 。</p>
<p><strong>经过如上面的一轮循环，我们就找到了字符串中关于每个位置i的最大回文串半径r[i] ！！！！</strong></p>
<p>设L[i]为x新字符串中以newstr[i]为中心的<strong>最长回文串长度</strong></p>
<p>那么显然有 L[i]  = 2 * r[i] - 1 </p>
<p>容易知道 L[i]的长度总为奇数字符串的长度</p>
<p>对于两种字符串 #a#b#a#或#a#a#</p>
<p><strong>其对应的回文串长度（L -1）/2 即为原来的字符串长度！</strong></p>
<p><strong>该值为r[i] - 1</strong>    ！！！</p>
<p>那么想要找到这一个字符串中最长的回文串的长度，不断更新r[i] - 1的最大值即可！！</p>
<p>于是用来求最长回文串长度的代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manacher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="keyword">int</span> max_len = <span class="number">0</span> ; </span><br><span class="line">   <span class="keyword">int</span> id , maxid = <span class="number">0</span> ; </span><br><span class="line">   len = <span class="number">2</span> * len + <span class="number">2</span> ； </span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i ++ )</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">if</span>(maxid &gt; i )</span><br><span class="line">   r[i] = <span class="built_in">min</span>(r[<span class="number">2</span> * id - i] , maxid - i ) ; </span><br><span class="line">   <span class="keyword">else</span> r[i] = <span class="number">1</span> ; </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">while</span>(newstr[i + r[i]] == newstr[i - r[i]])</span><br><span class="line">         r[i] ++ ; </span><br><span class="line">   <span class="keyword">if</span>( r[i] + i &gt; maxid)</span><br><span class="line">   &#123;</span><br><span class="line">       maxid = r[i] + i ;</span><br><span class="line">       id = i ; </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   max_len = <span class="built_in">max</span>(max_len,r[i] - <span class="number">1</span> );</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,max_len) ; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是马拉车算法的教程，有一说一马老先生是真的NB！</p>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>回文串</tag>
      </tags>
  </entry>
</search>
